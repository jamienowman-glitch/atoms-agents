# The Law of Agents: Atoms-UI Architecture

## Active Initiatives: MAYBES & HAZE
- **MAYBES**: Note-taking city canvas where ToolPill/ToolPop create nodes (text/audio/image). Nodes can be forwarded to Harness flows. Data stored in Supabase registry; media stored in S3 with URI refs; tenant-compute first.
- **HAZE**: Nexus Explorer planetary canvas (first-person on curved surface). Client device CPU/GPU for interactive render; server render only for export/offline. Uses HAZE muscles (surface renderer, runner, preview, optional contours) and registers via Supabase.


> **The Northstar**: "We are creating Shopify, Klaviyo, Photoshop, CapCut... all run by Agents and Humans on collaborative Canvases."

## ğŸ›‘ THE ATOMIC MANDATE
1.  **Never Monolith**: Every concern must be its own "Atom" (Table, Component, Service, Site).
2.  **Collaborative Core**: The "Canvas" is the shared workspace for Humans and Agents.
3.  **Atomic Expansion**: We will not have one central site. We will have many microsites targeting individual markets.
4.  **Registry First**: "If we hit something new, we add it to the Registry."
5.  **Tenant Compute First (Production)**: Interactive rendering must default to **client device CPU/GPU**. Server render only for explicit export/offline requests. **No local fallbacks** in production.

## ğŸ—ºï¸ Strategic Infrastructure & Auth
> **CRITICAL**: These documents define The Law for Auth, Infrastructure, and Nexus Architecture. Read them before planning any changes.

*   [Auth & Key Playbook (GCP/AWS)](docs/infra/NORTHSTAR_AUTH_SETUP.md)
*   [Nexus Architecture (Domains & Isolation)](docs/infra/NEXUS_ARCHITECTURE.md)

> **Context**: This repository (`atoms-ui`) defines the standard for "Agentic Canvases". All code generated by Agents MUST adhere to this constitution.

## 1. The Skills (Agent Capabilities)
Agents must check `.agent/skills/` for specialized instruction sets.
-   **Canvas Contract Builder** (`.agent/skills/canvas-contract-builder`): How to build new Canvases from a contract.
-   **Console Extend** (`.agent/skills/console-extend`): How to add tools to the Dashboard.
-   **Realtime Harness** (`.agent/skills/realtime-harness`): How to build Harness/Canvas realtime (SSE truth, sidecars, no new routes).

## ğŸ” REALTIME + HARNESS CONTRACT (V1)
**Canonical Doc:** `docs/plans/2026-01-27_realtime-collab-contract-and-atomic-task-plan.md`
**Alignment Retrofit:** `docs/plans/2026-01-28_realtime-retrofit-alignment.md`

*   **One Transport:** Reuse the shared `CanvasTransport` (do not create a second transport).
*   **No New Routes:** Harnesses/canvases never invent backend routes; they only consume the canonical `atoms-core` gateway.
*   **No DOM Streaming:** Stream canonical state (`token_patch` / `state_patch`), not browser DOM/HTML.
*   **Sidecars Only:** Image/video/audio are refs (S3 `artifact_id`/`uri`) and are permission-gated.
*   **Lens Naming:** Runtime lenses (policy) â‰  UI lens slots (panels) â‰  CanvasLens (view selector).

## 2. The Hierarchy
We follow a strict separation of concerns, inspired by Atomic Design but tailored for AI-Driven Tooling.

### Level 1: The Harness (Global)
-   **Role**: The "Shell" that holds the tools. It is **Canvas Agnostic**.
-   **Components**: `ToolHarness`, `ToolPill` (Top/Right), `ToolPop` (Bottom), `ChatRail` (Left).
-   **Transport**: MUST use `lib/gate3/transport`. The Harness instances `CanvasTransport` and shares it via Context.
-   **State**: Manages `ToolControlContext`. All "Tools" (sliders, toggles) live here and sync via `transport.sendCommand`.
-   **Rule**: The Harness NEVER knows about the specific canvas content. It only broadcasts signals (tool IDs).

### Level 2: The Controller (`Connected{Block}.tsx`)
-   **Role**: The "Traffic Controller". The specific implementation of a Block type.
-   **Responsibility**:
    1.  **Hydration**: Calls `useToolState` to read Harness signals.
    2.  **Logic**: Calls `useVarioEngine`, `useFeedMapper`, etc.
    3.  **Composition**: Passes final, calculated props down to the Molecules/Atoms.
-   **Rule**: This is the ONLY place where `useToolControl` or `useToolState` is allowed. Lower levels must be "dumb".
-   **Rule**: ALL Mutations must go through `transport.sendCommand`. DO NOT use `fetch` directly.

### Level 3: The Molecule (`{Name}Grid.tsx`)
-   **Role**: The "Container". Defines the layout and structure.
-   **Responsibility**:
    1.  **Layout**: Handles CSS Grid, Flexbox, Spacing variables.
    2.  **Mapping**: Loops over data arrays and renders Atoms.
    3.  **Styles**: Receives global style tokens (bg, color) and applies them to container CSS vars.
-   **Rule**: Never fetch data here. Never call hooks. Receive strictly typed props.

### Level 4: The Atom (`{Name}Tile.tsx`)
-   **Role**: The "Pixel". Pure presentation.
-   **Responsibility**:
    1.  **Render**: Displays the image, text, button.
    2.  **Interaction**: Minimal local interaction (hover state, simple click).
-   **Rule**: 100% Pure Component. No side effects.

## 2. The Standards

### Typography (Vario Engine)
All typography MUST use the global `useVarioEngine` hook.
-   **Do Not**: Hardcode `font-family: Roboto`.
-   **Do**: Pass `fontFamily` index and axes to `useVarioEngine` and apply the returned style.

### CSS Variables
We favor injection of CSS Variables at the *Molecule* level.
-   The Molecule receives `styleBgColor` prop.
-   The Molecule sets `style={{ '--bg': styleBgColor }}`.
-   The Atom uses `background: var(--bg)`.
*Reason*: Performance and cleaner DOM during rapid AI updates.

### File Structure (Standardized)
```text
canvases/{name}/
â”œâ”€â”€ index.ts                # Exports Canvas
â”œâ”€â”€ {Name}Canvas.tsx        # The Main Entry
â”œâ”€â”€ blocks/
â”‚   â”œâ”€â”€ Connected{Name}.tsx # The Controller
â”‚   â”œâ”€â”€ molecules/
â”‚   â”‚   â””â”€â”€ {Name}Grid.tsx  # The Molecule
â”‚   â”œâ”€â”€ atoms/
â”‚   â”‚   â””â”€â”€ {Name}Tile.tsx  # The Atom
â”‚   â””â”€â”€ modifiers/          # Optional (Rows, dividers)
â””â”€â”€ logic/                  # Optional (Mappers)

# 3. The Registry (The Source of Truth)

> **Context**: The Registry is now **DB-first** (Supabase). The legacy file-based `atoms-registry` directory has been **deprecated and quarantined** to prevent drift.

## Multi-Registry Architecture
The Registry is not a single list. It is a Federation of verified assets:
1.  **Muscles** (DB-backed): Backend Capabilities (Video, Audio, CAD).
2.  **Canvases** (DB-backed): UI Templates (VideoEditor, GanttChart).
3.  **UI Atoms** (DB-backed): Reusable UI Components (ClipTile, ScrubBar).
4.  **Connectors** (DB-backed): External APIs (Shopify, YouTube).

## The Hybrid Bridge (Migration Strategy)
To bridge the gap between `northstar-engines` (Legacy) and `atoms-ui` (New World):
1.  **(Deprecated)** The old harvest/mount flow wrote YAML into `atoms-registry` and exposed it via the legacy Engine.
2.  **(Current)** `atoms-ui` should consume registries via DB-backed APIs (Supabase / `atoms-core`) with proper auth and tenant isolation.

## Law of the Contract Builder (Persistence)
-   The **Contract Builder** IS the authoring tool.
-   **Save Target**: Contracts are saved to the DB registry (Supabase).
-   **Generation**: The Agent reads the saved DB contract (or exported snapshot) to generate React code.
-   **Loop**:
    1.  User edits Form in Contract Builder -> Saves to DB registry.
    2.  User asks Agent "Update Code" -> Agent reads DB contract -> Updates `atoms-ui/canvases`.


```