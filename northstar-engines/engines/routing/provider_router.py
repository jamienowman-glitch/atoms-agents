import yaml
import logging
import json
from typing import Dict, Any, Optional
from pathlib import Path

# Placeholder for actual model clients
class ModelClient:
    async def generate(self, provider: str, model: str, prompt: str) -> str:
        # In a real implementation, this would call the specific provider SDK
        # attempting to hit the API.
        # For simulation, we might raise exceptions based on provider to test fallback.
        pass

class ProviderRouter:
    def __init__(self, agents_path: str = "../../northstar-agents"):
        self.agents_path = Path(agents_path).resolve()
        self.logger = logging.getLogger("routing")
        
    def _load_card(self, card_id: str) -> Dict[str, Any]:
        # Assumes card_id format 'routing.card_name' maps to '.../routing/card_name.yaml'
        # This is a simplified loader for the router
        _, name = card_id.split(".")
        path = self.agents_path / "src" / "northstar" / "registry" / "cards" / "routing" / f"{name}.yaml"
        if not path.exists():
             raise FileNotFoundError(f"Routing card not found: {path}")
        
        with open(path, "r") as f:
            return yaml.safe_load(f)

    async def route_request(self, routing_card_id: str, prompt: str, agent_name: str = "Unknown") -> str:
        card = self._load_card(routing_card_id)
        rules = card.get("rules", [])
        
        last_error = None
        
        for rule in rules:
            if "attempt" in rule:
                attempt = rule["attempt"]
                provider = attempt["provider"]
                model = attempt["model"]
                
                try:
                    # Logic to attempt generation
                    # client = get_client(provider)
                    # result = await client.generate(...)
                    
                    # Simulating success/failure for the sake of the router logic structure
                    # Real implementation would await the actual call
                    
                    self._log_decision(agent_name, provider, "SUCCESS", None, card.get("strategy"))
                    return f"Generated by {provider}/{model}"
                    
                except Exception as e:
                    # Capture error type for fallback matching
                    last_error = e
                    self._log_decision(agent_name, provider, "ERROR", None, card.get("strategy"), error=str(e))
                    continue # Try next rule logic (which might be an on_error handler)

            elif "on_error" in rule:
                # Check if this error handler matches the last error
                # Simplified matching logic
                if not last_error:
                    continue
                
                # If types match (simplified)
                fallback = rule["on_error"]["fallback"]
                fallback_provider = fallback["provider"]
                fallback_model = fallback["model"]
                
                try:
                    # Attempt fallback
                     self._log_decision(agent_name, fallback_provider, "FALLBACK_ATTEMPT", last_error, card.get("strategy"))
                     return f"Generated by {fallback_provider}/{fallback_model}"
                except Exception as e:
                    last_error = e
                    continue
                    
        raise Exception("All routing attempts failed")

    def _log_decision(self, agent_name: str, provider: str, status: str, caused_by_error: Optional[Exception], cost_tier: str, error: str = None):
        event = {
            "event": "ROUTING_DECISION",
            "agent_name": agent_name,
            "attempted": provider,
            "status": status,
            "cost_tier": cost_tier
        }
        if caused_by_error:
             # Map exception to status code/limit if possible
             if "RateLimit" in str(caused_by_error): # Naive check
                 event["status"] = "RATE_LIMIT"
             event["fallback"] = provider # The one we just tried was the fallback/attempt
        
        # In a real system this goes to LogLens/Observability
        print(json.dumps(event))
